'use strict';

require('./util.node.js');
var fs = require('fs');

// This is basically simple translation from JSON to C source code in order
// to magically bundle the compiled parser into the `toy` executable.

var compile = require('./compile');

var escapeStringChar = function (c) {
    var map = {
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        '\\': '\\\\',
        '"': '\\"'
    };
    return map[c] || c;
}

var escapeString = function (string) {
    var e = '';
    var i = 0;
    while (i < string.length) {
        e = e + escapeStringChar(string[i]);
        i = i + 1;
    }
    return '"' + e + '"';
};

var translateFunction = function (compiled) {
    var output = '';
    var emit = function (s) {
        output = output + s;
    };

    emit('{\n');

    if (compiled.paramName) {
        emit('  .param_name = "' + compiled.paramName + '",\n');
    }

    emit('  .code = (unsigned char[]){\n');
    var i = 0;
    while (i < compiled.code.length) {
        var byte = compiled.code[i];
        emit('    /* ' + i + ' */ ');
        if (typeof byte === 'string') {
            emit('opcode_' + byte);
        }
        if (typeof byte === 'number') {
            emit(byte);
        }
        emit(',\n');
        i = i + 1;
    }
    emit('  },\n');

    emit('  .code_length = ' + compiled.code.length + ',\n');

    var consts = compiled.consts;

    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65673
    if (consts.length) {
        emit('  .consts = (value_t[' + consts.length + ']){},\n');
        emit('  .bconsts = (bvalue_t[]){\n');
        i = 0;
        while (i < consts.length) {
            var value = consts[i];
            emit('    /* ' + i + ' */ ');
            if (typeof value === 'string') {
                emit('bv_str(' + escapeString(value) + ')');
            }
            if (typeof value === 'number') {
                emit('bv_nbr(' + value + ')');
            }
            emit(',\n');
            i = i + 1;
        }
        emit('  },\n');
    }

    emit('  .const_count = ' + consts.length + ',\n');

    emit('  .file = &file,\n');

    emit('};\n');

    return output;
};

var translate = function (source) {
    var output = '';
    var emit = function (s) {output = output + s;};

    emit('// AUTOGENERATED FILE\n\n');
    emit('#include "toy.h"\n');
    emit('#include "bvalue.h"\n\n');

    var funcs = compile(source);

    emit('static compiled_file_t file = {\n');
    emit('  .func_count = ' + funcs.length + ',\n');
    emit('  .funcs = (compiled_func_t[' + funcs.length + ']){},\n');
    emit('};\n\n');

    var i = 0;
    while (i < funcs.length) {
        var func = funcs[i];
        emit('static compiled_func_t func' + i + ' = ');
        emit(translateFunction(func));
        emit('\n');
        i = i + 1;
    }

    emit('compiled_file_t *get_builtin_file(void) {\n');

    emit('  compiled_func_t funcs[' + funcs.length + '] = {');
    i = 0;
    while (i < funcs.length) {
        emit('func' + i + ', ');
        i = i + 1;
    }
    emit('};\n\n');

    emit('  memmove(file.funcs, funcs, sizeof(funcs));\n');
    emit('  for (int i = 0; i < ' + funcs.length + '; i++) {\n');
    emit('    compiled_func_t *func = file.funcs + i;\n');
    emit('    bvalue_array_to_v(func->consts, func->bconsts, func->const_count);\n');
    emit('  }\n');
    emit('  return &file;\n');
    emit('}\n');

    return output;
};

var source = fs.readFileSync('compile.js').toString();
console.log(translate(source));
